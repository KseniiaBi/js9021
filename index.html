<!DOCTYPE html>
<html lang="en">
<head>
	<title>JS FE</title> 
	<meta charset="utf-8">
	<meta name="viewport" content="width=device-width,initial-scale=1"> 
</head>
<body>



<script>


// 	1)Дан массив [ [1, 2, 3], [4, 5, 6], [7,8,9] ]. Выведите на экран цифру 4 из этого массива.
// arr[1][0]

// 2) Сделайте функцию isNumberInRange, которая параметром принимает число, начало и конец диапазона и проверяет, что оно больше начала  и меньше конца. Если это так - пусть функция возвращает true, если не так - false.

function isNumberInRange(num, start, end){
	let isOk = false;
	if(num >= start && num <= end){
		isOk = true;
	}
	console.log(isOk);
}

isNumberInRange(3,1, 10);
isNumberInRange(13,1, 10);

// 3) Создайте объект с днями недели. Ключами в нем должны служить номера дней от начала недели (понедельник - первый и т.д.). Выведите на экран текущий день недели.
// days['2'] => vtornik

// 4) Пусть теперь в переменной lang хранится язык (она принимает одно из значений или 'ru', или 'en' - либо то, либо то), а в переменной day - номер дня. Выведите словом день недели, соответствующий переменным lang и day. То есть: если, к примеру, lang = 'ru' и day = 3 - то выведем 'среда'.


let days = {
	en: {
		1: 'Mo',
		2: 'Tue',
		3: 'Wed'
		// ...
	},
	ru: {
		1: 'Пн',
		2: 'Вт',
		3: 'Ср'
		// ...
	}
}
// let lang = confirm('En or ru') ? 'en' : 'ru';
// let day = +prompt('Type day num 1-7');

// console.log(days[lang][day]);

// 5) Оператор == сравнивает переменные объектов, проверяя, ссылаются ли они на один объект. Но иногда полезно было бы сравнить объекты по содержимому.Напишите функцию deepEqual, которая принимает два значения и возвращает true, только если это два одинаковых значения или это объекты, свойства которых имеют одинаковые значения, если их сравнивать рекурсивным вызовом deepEqual.Чтобы узнать, когда сравнивать величины через ===, а когда – объекты по содержимому, используйте оператор typeof. Если он выдаёт “object” для обеих величин, значит нужно делать глубокое сравнение. Не забудьте об одном исключении, случившемся из-за исторических причин: “typeof null” тоже возвращает “object”.

function deepEqual(o1, o2){
	if(typeof(o1) == typeof(o2) && typeof(o1) != 'object'){
		if(o1 == o2){
			return true;
		}
	}
	else{
		if(o1 === null || o2 === null){
			if( o1 != o2){
				return false;
			}
			else{
				return true;
			}
		}

		let areEqual = false;
		let o1Count = 0;
		let o2Count = 0;

		for(let prop in o1){
			o1Count++;
		}
		for(let prop in o2){
			o2Count++;
		}

		if(o1Count != o2Count){
			return areEqual;
		}
		else{
			let eqalProps = 0;
			for(let key in o1){
				if(o1[key] === o2[key]){
					eqalProps++;
				}
			}
			if(eqalProps == o1Count){
				areEqual = true;
			}
			return areEqual;
		}
	}
}


let obj = {
	name: 'Dan',
	book: 'A&D'
}

let author = {
	name: 'Dan',
	book: 'A&D'
}

console.log(deepEqual(obj, author));

let obj2 = {
	name: 'Dan',
	book: 'A&D',
	age: 22
}
console.log(deepEqual(obj, obj2));

let admin = {
	pass: '34wrterg',
	role: 'admin'
}

console.log(deepEqual(admin, author));

console.log(deepEqual(admin, null));
console.log(deepEqual(null, null));
console.log(deepEqual(2, 2));
console.log(deepEqual(2, '2'));


// 6) Напишите функции для умножения и вычитания целых чисел, используя из арифметических операций только оператор суммирования.


function mul(n, m){
	let result = n;
	for(let i = 1; i < m; i++){
		result += n;
	}
	console.log(result);
}

mul(2,5);
mul(3,4);


function extr(a, b){
	for(let i = 0; i < b; i++){
		a += -1;
	}

	console.log(a);
}

extr(10,4);
extr(10,12);


//  **** divide (use proportions)

</script>

</body>
</html>